<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Cesium Map</title>
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.115/Build/Cesium/Cesium.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Turf.js/6.5.0/turf.min.js"></script>
    <link
      href="https://cesium.com/downloads/cesiumjs/releases/1.115/Build/Cesium/Widgets/widgets.css"
      rel="stylesheet"
    />
  </head>
  <body>
    <div id="cesiumContainer" style="width: 100%; height: 100vh"></div>

    <script>
      const cesiumViewer = new Cesium.Viewer('cesiumContainer', {
        terrain: Cesium.Terrain.fromWorldTerrain({
          requestWaterMask: false,
          requestVertexNormals: false,
        }),
      })

      const MARGIN = 100 // m

      Cesium.Ion.defaultAccessToken =
        'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIzZTI5NTZhYi1jOTI5LTQ0Y2EtODE4Ni1kMTY5N2I0NWUxOTIiLCJpZCI6MTk3MTMyLCJpYXQiOjE3MDg1ODY3MjV9.7dwPoXuM4xUPC8ezK5OxkDy7aBVSITQUIJD0Cp6ZukI'

      // Define the original polygon coordinates
      const polygonPoints = [
        turf.point([115.87700696810903, -31.99666995816703]),
        turf.point([115.88060098754961, -31.996682830136816]),
        turf.point([115.88061111578976, -31.99800989224804]),
        turf.point([115.87699265758124, -31.99810180503983]),
      ]
      const polygonCoords = Cesium.Cartesian3.fromDegreesArray([
        115.87700696810903, -31.99666995816703, 115.88060098754961, -31.996682830136816, 115.88061111578976,
        -31.99800989224804, 115.87699265758124, -31.99810180503983,
      ])

      let length = polygonPoints.length
      const parallelLines = polygonPoints.reduce((acc, cur, index) => {
        const nextIndex = (index + 1) % length
        const pointA = cur
        const pointB = polygonPoints[nextIndex]

        const edge = turf.lineString([
          [pointA.geometry.coordinates[0], pointA.geometry.coordinates[1]],
          [pointB.geometry.coordinates[0], pointB.geometry.coordinates[1]],
        ])
        const offsetEdge = turf.lineOffset(edge, -MARGIN, { units: 'meters' })

        const startCoord = offsetEdge.geometry.coordinates[0] // Start point coordinates
        const endCoord = offsetEdge.geometry.coordinates[offsetEdge.geometry.coordinates.length - 1] // End point coordinates

        // Create Turf.js points from the coordinates
        let pointC = turf.point(startCoord)
        let pointD = turf.point(endCoord)

        // Calculate bearings from the midpoint to each endpoint
        const midpoint = turf.midpoint(pointC, pointD)
        const bearingToC = turf.rhumbBearing(midpoint, pointC)
        const bearingToD = turf.rhumbBearing(midpoint, pointD)

        // Calculate point C, margin * 1000 meters extended from A in the opposite direction
        pointC = turf.rhumbDestination(pointC, 200, bearingToC, {
          units: 'kilometers',
        })

        // Calculate point D, margin * 1000 meters extended from B in the same direction
        pointD = turf.rhumbDestination(pointD, 200, bearingToD, {
          units: 'kilometers',
        })

        const line = turf.lineString([
          [pointC.geometry.coordinates[0], pointC.geometry.coordinates[1]],
          [pointD.geometry.coordinates[0], pointD.geometry.coordinates[1]],
        ])

        acc.push(line)

        return acc
      }, [])

      length = parallelLines.length
      const marginPoints = parallelLines.reduce((acc, line, index) => {
        const nextIndex = (index + 1) % length
        const nextLine = parallelLines[nextIndex]
        if (nextLine) {
          const intersects = turf.lineIntersect(line, nextLine)
          const intersectionPoints = intersects.features
          acc.push(...intersectionPoints)
        }
        return acc
      }, [])

      // Add the original polygon to the map
      const mainPolygon = cesiumViewer.entities.add({
        polygon: {
          hierarchy: polygonCoords,
          material: Cesium.Color.BLUE.withAlpha(0.5), // Semi-transparent blue
        },
      })

      const marginPolygonPoints = marginPoints
        .map((point) => {
          return point.geometry.coordinates
        })
        .flat()
      const marginPolygonPointsInCartesian = Cesium.Cartesian3.fromDegreesArray(marginPolygonPoints)
      const marginPolygon = cesiumViewer.entities.add({
        polygon: {
          hierarchy: Cesium.Cartesian3.fromDegreesArray(marginPolygonPoints),
          material: Cesium.Color.RED.withAlpha(0.5), // Semi-transparent red
        },
      })

      const polygonHierarchy = mainPolygon?.polygon?.hierarchy?.getValue(cesiumViewer.clock.currentTime)
      const bs = Cesium.BoundingSphere.fromPoints(polygonHierarchy.positions)

      cesiumViewer.camera.setView({
        destination: bs.center,
        orientation: {
          heading: cesiumViewer.camera.heading, // Maintain the current heading angle
          pitch: Cesium.Math.toRadians(-90), // Set the desired pitch angle in radians (top-down view)
          roll: cesiumViewer.camera.roll, // Maintain the current roll angle
        },
      })
    </script>
  </body>
</html>
