<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Cesium Map</title>
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.115/Build/Cesium/Cesium.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Turf.js/6.5.0/turf.min.js"></script>
    <link
      href="https://cesium.com/downloads/cesiumjs/releases/1.115/Build/Cesium/Widgets/widgets.css"
      rel="stylesheet"
    />
  </head>
  <body>
    <div id="cesiumContainer" style="width: 100%; height: 100vh"></div>

    <script>
      const cesiumViewer = new Cesium.Viewer('cesiumContainer', {
        terrain: Cesium.Terrain.fromWorldTerrain({
          requestWaterMask: false,
          requestVertexNormals: false,
        }),
      })

      const MARGIN = 2 // m

      Cesium.Ion.defaultAccessToken =
        'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIzZTI5NTZhYi1jOTI5LTQ0Y2EtODE4Ni1kMTY5N2I0NWUxOTIiLCJpZCI6MTk3MTMyLCJpYXQiOjE3MDg1ODY3MjV9.7dwPoXuM4xUPC8ezK5OxkDy7aBVSITQUIJD0Cp6ZukI'

      // Define the original polygon coordinates
      const polygonPoints = [
        turf.point([115.87730300372058, -31.99815649565551]),
        turf.point([115.8776101166282, -31.998155358311532]),
        turf.point([115.87729830985518, -31.998288996132025]),
      ]
      const polygonCoords = Cesium.Cartesian3.fromDegreesArray([
        115.87730300372058, -31.99815649565551, 115.8776101166282, -31.998155358311532, 115.87729830985518,
        -31.998288996132025,
      ])

      let length = polygonPoints.length
      const parallelLines = polygonPoints.reduce((acc, cur, index) => {
        const nextIndex = (index + 1) % length
        const pointA = cur
        const pointB = polygonPoints[nextIndex]

        const edge = turf.lineString([
          [pointA.geometry.coordinates[0], pointA.geometry.coordinates[1]],
          [pointB.geometry.coordinates[0], pointB.geometry.coordinates[1]],
        ])
        const offsetEdge = turf.lineOffset(edge, -MARGIN, { units: 'meters' })

        const startCoord = offsetEdge.geometry.coordinates[0] // Start point coordinates
        const endCoord = offsetEdge.geometry.coordinates[offsetEdge.geometry.coordinates.length - 1] // End point coordinates

        // Create Turf.js points from the coordinates
        let pointC = turf.point(startCoord)
        let pointD = turf.point(endCoord)

        // Calculate the bearing from A to B
        const bearingCD = turf.bearing(pointC, pointD)

        // Calculate point C, 10 meters extended from A in the opposite direction
        pointC = turf.destination(pointC, MARGIN * 20, bearingCD - 180, { units: 'meters' })

        // Calculate point D, 10 meters extended from B in the same direction
        pointD = turf.destination(pointD, MARGIN * 20, bearingCD, { units: 'meters' })

        const line = turf.lineString([
          [pointC.geometry.coordinates[0], pointC.geometry.coordinates[1]],
          [pointD.geometry.coordinates[0], pointD.geometry.coordinates[1]],
        ])

        acc.push(line)

        return acc
      }, [])

      length = parallelLines.length
      const marginPoints = parallelLines.reduce((acc, line, index) => {
        const nextIndex = (index + 1) % length
        const nextLine = parallelLines[nextIndex]
        if (nextLine) {
          const intersects = turf.lineIntersect(line, nextLine)
          const intersectionPoints = intersects.features.map((feature) => {
            return feature
          })
          acc.push(...intersectionPoints)
        }
        return acc
      }, [])

      // Add the original polygon to the map
      const mainPolygon = cesiumViewer.entities.add({
        polygon: {
          hierarchy: polygonCoords,
          material: Cesium.Color.BLUE.withAlpha(0.5), // Semi-transparent blue
        },
      })

      const marginPolygonPoints = marginPoints
        .map((point) => {
          return point.geometry.coordinates
        })
        .flat()
      const marginPolygonPointsInCartesian = Cesium.Cartesian3.fromDegreesArray(marginPolygonPoints)
      const marginPolygon = cesiumViewer.entities.add({
        polygon: {
          hierarchy: Cesium.Cartesian3.fromDegreesArray(marginPolygonPoints),
          material: Cesium.Color.RED.withAlpha(0.5), // Semi-transparent red
        },
      })

      const polygonHierarchy = mainPolygon?.polygon?.hierarchy?.getValue(cesiumViewer.clock.currentTime)
      const bs = Cesium.BoundingSphere.fromPoints(polygonHierarchy.positions)

      cesiumViewer.camera.setView({
        destination: bs.center,
        orientation: {
          heading: cesiumViewer.camera.heading, // Maintain the current heading angle
          pitch: Cesium.Math.toRadians(-90), // Set the desired pitch angle in radians (top-down view)
          roll: cesiumViewer.camera.roll, // Maintain the current roll angle
        },
      })
    </script>
  </body>
</html>
